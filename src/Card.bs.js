// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nom = require("@line100/rescript-nom/src/Nom.bs.js");
var Seq = require("@line100/rescript-seq/src/Seq.bs.js");
var Util = require("./Util.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var Err = /* @__PURE__ */Caml_exceptions.create("Card.Err");

function cardGroup(arr) {
  var sortedValue = arr.map(function (param) {
          return param[0];
        }).sort(function (a, b) {
        return a - b | 0;
      });
  return Util.$$Array.group(sortedValue, (function (v) {
                return [
                        v,
                        1
                      ];
              }), (function (param, v) {
                var lastV = param[0];
                if (lastV === v) {
                  return [
                          lastV,
                          param[1] + 1 | 0
                        ];
                }
                
              }));
}

function isAnyOf(n) {
  return function (param, param$1) {
    return Nom.satisfy((function (param) {
                  return param[1] === n;
                }), (function (e) {
                  if (e !== undefined) {
                    return /* AnyGroupFailed */1;
                  } else {
                    return /* ReachEndError */0;
                  }
                }), param, param$1);
  };
}

function isValueEqual(v) {
  return function (param, param$1) {
    return Nom.satisfy((function (param) {
                  return param[0] === v;
                }), (function (e) {
                  if (e !== undefined) {
                    return /* CardValueFailed */2;
                  } else {
                    return /* ReachEndError */0;
                  }
                }), param, param$1);
  };
}

function isProgressionOf(matcher, minLen) {
  var p = Curry._3(Nom.Multi.reduceBy, matcher, (function (param, param$1) {
          var v = param$1[0];
          if ((param[0] + 1 | 0) === v) {
            return [
                    v,
                    param[1] + 1 | 0
                  ];
          }
          
        }), [
        0,
        0
      ]);
  return function (param, param$1) {
    return Nom.mapPassed(p, (function (rest, v, i) {
                  if (v[1] >= minLen) {
                    return {
                            TAG: /* Pass */0,
                            _0: rest,
                            _1: v,
                            _2: i
                          };
                  } else {
                    return {
                            TAG: /* Fail */1,
                            _0: rest,
                            _1: /* ProgressionTooShortFailed */3,
                            _2: i
                          };
                  }
                }), param, param$1);
  };
}

function noValue(p) {
  return function (param, param$1) {
    return Nom.mapValue(p, (function (param) {
                  return [
                          0,
                          0
                        ];
                }), param, param$1);
  };
}

function combine(p1, p2, name) {
  var partial_arg = Curry._3(Nom.Sequence.terminated, p1, p2, (function (param) {
          return /* PatternMatchFailed */{
                  _0: name
                };
        }));
  return function (param, param$1) {
    return Nom.allConsuming(partial_arg, (function (param) {
                  return /* PatternNotReachEndFailed */4;
                }), param, param$1);
  };
}

function single(p) {
  return function (param, param$1) {
    return Nom.allConsuming(p, (function (param) {
                  return /* PatternNotReachEndFailed */4;
                }), param, param$1);
  };
}

var isOne = isAnyOf(1);

var isPair = isAnyOf(2);

var isThree = isAnyOf(3);

var isFour = isAnyOf(4);

function p(param, param$1) {
  return Nom.tuple(isOne, isOne, param, param$1);
}

function is2Single(param, param$1) {
  return Nom.mapValue(p, (function (param) {
                return [
                        0,
                        0
                      ];
              }), param, param$1);
}

function p$1(param, param$1) {
  return Nom.tuple(isPair, isPair, param, param$1);
}

function is2Pair(param, param$1) {
  return Nom.mapValue(p$1, (function (param) {
                return [
                        0,
                        0
                      ];
              }), param, param$1);
}

var isJokerBlack = isValueEqual(16);

var isJokerRed = isValueEqual(17);

var isProgression1 = isProgressionOf(isOne, 5);

var isProgression2 = isProgressionOf(isPair, 3);

var isProgression3 = isProgressionOf(isThree, 2);

function one(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* One */0,
                        _0: param[0]
                      };
              }), (function (param, param$1) {
                return Nom.allConsuming(isOne, (function (param) {
                              return /* PatternNotReachEndFailed */4;
                            }), param, param$1);
              }), param, param$1);
}

function pair(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Pair */1,
                        _0: param[0]
                      };
              }), (function (param, param$1) {
                return Nom.allConsuming(isPair, (function (param) {
                              return /* PatternNotReachEndFailed */4;
                            }), param, param$1);
              }), param, param$1);
}

var partial_arg = combine(isThree, isOne, "three1");

function three1(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Three1 */2,
                        _0: param[0]
                      };
              }), partial_arg, param, param$1);
}

var partial_arg$1 = combine(isThree, isPair, "tree2");

function three2(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Three2 */3,
                        _0: param[0]
                      };
              }), partial_arg$1, param, param$1);
}

var partial_arg$2 = combine(isFour, is2Single, "four2");

function four2(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Four2 */4,
                        _0: param[0]
                      };
              }), partial_arg$2, param, param$1);
}

var partial_arg$3 = combine(isFour, is2Pair, "four4");

function four4(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Four4 */5,
                        _0: param[0]
                      };
              }), partial_arg$3, param, param$1);
}

function progression1(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Progression */6,
                        _0: param[0],
                        _1: param[1]
                      };
              }), (function (param, param$1) {
                return Nom.allConsuming(isProgression1, (function (param) {
                              return /* PatternNotReachEndFailed */4;
                            }), param, param$1);
              }), param, param$1);
}

function progression2(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* PairProgression */7,
                        _0: param[0],
                        _1: param[1]
                      };
              }), (function (param, param$1) {
                return Nom.allConsuming(isProgression2, (function (param) {
                              return /* PatternNotReachEndFailed */4;
                            }), param, param$1);
              }), param, param$1);
}

function plane(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Plane */8,
                        _0: param[0],
                        _1: param[1]
                      };
              }), (function (param, param$1) {
                return Nom.allConsuming(isProgression3, (function (param) {
                              return /* PatternNotReachEndFailed */4;
                            }), param, param$1);
              }), param, param$1);
}

function bomb(param, param$1) {
  return Nom.context((function (param) {
                return {
                        TAG: /* Bomb */9,
                        _0: param[0]
                      };
              }), (function (param, param$1) {
                return Nom.allConsuming(isFour, (function (param) {
                              return /* PatternNotReachEndFailed */4;
                            }), param, param$1);
              }), param, param$1);
}

function p$2(param, param$1) {
  return Nom.tuple(isJokerBlack, isJokerRed, param, param$1);
}

function partial_arg$4(param, param$1) {
  return Nom.allConsuming(p$2, (function (param) {
                return /* PatternNotReachEndFailed */4;
              }), param, param$1);
}

function jokerBomb(param, param$1) {
  return Nom.context((function (param) {
                return /* JokerBomb */0;
              }), partial_arg$4, param, param$1);
}

var rule = Nom.alt({
      hd: one,
      tl: {
        hd: pair,
        tl: {
          hd: three1,
          tl: {
            hd: three2,
            tl: {
              hd: four2,
              tl: {
                hd: four4,
                tl: {
                  hd: progression1,
                  tl: {
                    hd: progression2,
                    tl: {
                      hd: plane,
                      tl: {
                        hd: bomb,
                        tl: {
                          hd: jokerBomb,
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }, (function (param) {
        return /* PatternAllBranchFailed */5;
      }));

function match(cards) {
  var seq = Seq.fromArray(cardGroup(cards));
  var match$1 = rule(seq, 0);
  if (match$1.TAG === /* Pass */0) {
    return {
            TAG: /* Ok */0,
            _0: match$1._1
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: match$1._1
          };
  }
}

exports.Err = Err;
exports.cardGroup = cardGroup;
exports.isAnyOf = isAnyOf;
exports.isValueEqual = isValueEqual;
exports.isProgressionOf = isProgressionOf;
exports.noValue = noValue;
exports.combine = combine;
exports.single = single;
exports.isOne = isOne;
exports.isPair = isPair;
exports.isThree = isThree;
exports.isFour = isFour;
exports.is2Single = is2Single;
exports.is2Pair = is2Pair;
exports.isJokerBlack = isJokerBlack;
exports.isJokerRed = isJokerRed;
exports.isProgression1 = isProgression1;
exports.isProgression2 = isProgression2;
exports.isProgression3 = isProgression3;
exports.one = one;
exports.pair = pair;
exports.three1 = three1;
exports.three2 = three2;
exports.four2 = four2;
exports.four4 = four4;
exports.progression1 = progression1;
exports.progression2 = progression2;
exports.plane = plane;
exports.bomb = bomb;
exports.jokerBomb = jokerBomb;
exports.rule = rule;
exports.match = match;
/* isOne Not a pure module */
